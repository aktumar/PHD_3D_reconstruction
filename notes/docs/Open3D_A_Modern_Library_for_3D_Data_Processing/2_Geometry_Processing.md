```
Open3D: A Modern Library for 3D Data Processing

Problems:
1. Здесь только поддерживаемые форматы. Еще нужно будет для форматов создавать отдельный файл, чтобы знать абсолютно все существующие
2. Вторая подглава у меня совсем по другому работает, нужно тестировать на нормальных данных 
3. ply данные, типа bunny у меня не читает, все еще говорит что нет треугольников. Либо переписываю ply, либо ищу собственные
4. Реконструкция поверхности с альфа значением работает плохо. Неужели мне каждый раз нужно вручную выбирать значения, чтобы хоть что нибудь увидеть.
5. При деформации меша никакого преобразования не увидела. Либо у меня слишком простые модели, либо сама программа не работает, хоть я и меняла все значения. Орижинал имэдж выходит
6. Ключевые точки вообще не поняла как делать
```


- **COM1** - **File IO**

  1. **Point cloud**
  2. **Mesh**
  3. **Image**

  |                                                              | Point Cloud (read/write)                                     | Mesh (read/write)                                            | Image (read/write)                                           |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | xyz                                                          | `x`, `y`, `z` are the 3D coordinates                         | -                                                            | -                                                            |
  | xyzn                                                         | `nx`, `ny`, `nz` are the normals                             | -                                                            | -                                                            |
  | xyzrgb                                                       | `r`, `g`, `b` are in floats of range [0, 1] - colors         | -                                                            | -                                                            |
  | pts                                                          | `[x, y, z, i, r, g, b]` <br />`[x, y, z, r, g, b]` <br />`[x, y, z, i]`  <br />`[x, y, z]`, where `x`, `y`, `z`, `i` are of type `double` and `r`, `g`, `b` are of type `uint8` | -                                                            | -                                                            |
  | [ply](http://paulbourke.net/dataformats/ply/)                | Header   <br />Vertex List   <br />Face List   (lists of other elements) | Header   <br />Vertex List   <br />Face List   (lists of other elements) | -                                                            |
  | [pcd](http://pointclouds.org/documentation/tutorials/pcd_file_format.html) | # .PCD v.7 - Point Cloud Data file format <br />VERSION .7 <br />FIELDS x y z rgb <br />SIZE 4 4 4 4 <br />POINTS 213 <br />0.93773 0.33763 0 4.2108e+06 | -                                                            | -                                                            |
  | [stl](http://www.fabbers.com/tech/STL_Format)                | -                                                            | solid name<br />face normal n_i, n_j, n_k<br />outer loop<br />vertex v1x, v1y, v1z<br />vertex v2x, v2y, v2z<br />vertex v3x, v3y, v3z<br />endloop<br />endfacet<br />endsolid name | -                                                            |
  | [obj](http://paulbourke.net/dataformats/obj/)                | -                                                            | `v x y z w`<br />`vp u v w`<br />`vn i j k`<br />`vt u v w`<br />`p  v1 v2`<br />`l v1/vt1`<br />`f v1/vt1/vn1`<br />`curv u0 u1`<br />... | -                                                            |
  | [off](http://www.geomview.org/docs/html/OFF.html)            | -                                                            | [ST] [C] [N] [4] [n]OFF<br /> x[0]  y[0]  z[0]               | -                                                            |
  | [gltf/glb](https://github.com/KhronosGroup/glTF/tree/main/specification/2.0) | -                                                            | json                                                         | -                                                            |
  | [jpg](https://ru.wikipedia.org/wiki/JPEG)                    | -                                                            | -                                                            | фото без прозрачности, <br />важны соотношения качество/цветность/размер |
  | [png](https://ru.wikipedia.org/wiki/PNG)                     | -                                                            | -                                                            | фото с прозрачностью, <br />содержит гораздо меньше цветов,  |

  

- **COM2** - **Point cloud outlier removal** При сборе данных со сканирующих устройств дающее облако точек имеет тенденцию содержать шумы, которые хотелось бы удалить. 

  1. **Prepare input data** Облако точек загружается и субдискретизируется. 
  2. **Select down sample** (В общем говоря, данная тема показывает, как работать с граничными точками)
  3. **Statistical outlier removal**
  4. **Radius outlier removal**

- **COM3** - **Voxelization** Облака точек и треугольные сетки - очень гибкие, но нестандартные геометрические типы. Воксельная сетка - это еще один тип геометрии в 3D, который определяется в обычной 3D-сетке, тогда как воксель можно рассматривать как 3D-аналог пикселя в 2D. 

  <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_voxelization/knot_vox.gif" /></p>

  Приведенный ниже код демонстрирует использование путем первого рендеринга карт глубины из геометрии и использования этих карт глубины для вырезания плотной сетки вокселей. Результатом является заполненная сетка вокселей заданной формы.

  1. **From triangle mesh** (При вокселизации меша, воксельная сетка прокрашивается в единый черный цвет, но наверное можно это регулировать)
  2. **From point cloud** (При вокселизации облаков точек, воксельная сетка прокрашивается в разный цвет - это среднее значение всех точек воксела)
  3. **Inclusion test**
  4. **Voxel carving** (Предыдущие методы создают занятые воксели только на поверхности геометрии. Однако можно вырезать сетку вокселей из нескольких карт глубины или силуэтов)

- **COM4** - **Octree** Октодерево - это древовидная структура данных, в которой каждый внутренний узел имеет восемь дочерних элементов. Октодеревья обычно используются для пространственного разделения трехмерных облаков точек. Непустые листовые узлы октодерева содержат одну или несколько точек, которые попадают в одно и то же пространственное подразделение. Октодеревья представляют собой полезное описание трехмерного пространства и могут использоваться для быстрого поиска ближайших точек. 

  <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_voxelization/knot_octr.gif" /></p>

  1. **From point cloud** Каждая точка вставляется в дерево по пути от корневого узла к соответствующему конечному узлу на глубине max_depth. По мере увеличения глубины дерева внутренние (и, в конечном итоге, листовые) узлы представляют меньший раздел трехмерного пространства. Если облако точек имеет цвет, соответствующий листовой узел принимает цвет последней вставленной точки.

  2. **From voxel grid** Каждый воксель входной VoxelGrid обрабатывается как точка в трехмерном пространстве с координатами, соответствующими началу воксела. Каждый листовой узел принимает цвет соответствующего вокселя.

  3. **Traversal** Можно перемещаться по октодереву, что может быть полезно для поиска или обработки подразделов трехмерной геометрии. Предоставляя методу обхода обратный вызов, каждый раз при посещении узла (внутреннего или конечного) может выполняться дополнительная обработка.

     Способность к ранней остановке может быть использована для эффективной обработки пространственных областей, удовлетворяющих определенным условиям и используется только для обработки внутренних / листовых узлов с более чем определенным количеством точек.

  4. **Find leaf node containing point** Используя описанный выше механизм обхода, в октодереве можно быстро найти листовой узел, содержащий заданную точку.

- **COM5** - **Surface reconstruction** Во многих сценариях мы хотим создать плотную трехмерную геометрию, то есть треугольную сетку. Однако с помощью метода многовидового стерео или датчика глубины мы получаем только неструктурированное облако точек. Чтобы получить треугольную сетку из этого неструктурированного ввода, нам нужно выполнить реконструкцию поверхности. 

  1. **Alpha shapes** [Edelsbrunner1983] Обобщение выпуклой оболочки. Представьте себе огромную массу мороженого, содержащую точки S в виде кусочков твердого шоколада. Используя одну из этих сферических ложек для мороженого, мы вырезаем все части блока мороженого, до которых можем дотянуться, не натыкаясь на кусочки шоколада, тем самым даже вырезая отверстия внутри (например, части, недоступные простым перемещением ложки вне контейнера). В конечном итоге мы получим (не обязательно выпуклый) объект, ограниченный заглавными шапками, дугами и точками. Если мы теперь выпрямим все круглые грани в треугольники и линейные сегменты, мы получим интуитивное описание того, что называется альфа-формой S. (Чеее, описание от бога, найди нормальное описание)

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_surface_reconstruction/cube_rec.gif" /></p>

  2. **Ball pivoting** algorithm (BPA) [Bernardini1999] - это метод реконструкции поверхности, связанный с альфа-формами. Интуитивно представьте себе трехмерный шар с заданным радиусом, который мы бросаем на облако точек. Если он попадает в какие-либо 3 точки (и не проходит через эти 3 точки), он создает треугольники. Затем алгоритм начинает вращаться от краев существующих треугольников, и каждый раз, когда он попадает в 3 точки, через которые мяч не проваливается, мы создаем еще один треугольник.

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_surface_reconstruction/cube_rec2.png" /></p>

  3. **Poisson surface reconstruction** [Kazhdan2006] решает регуляризованную задачу оптимизации для получения гладкой поверхности. По этой причине реконструкция поверхности Пуассона может быть предпочтительнее методов, упомянутых выше, поскольку они дают негладкие результаты, поскольку точки PointCloud также являются вершинами результирующей треугольной сетки без каких-либо изменений.

     Важным параметром функции является глубина, которая определяет глубину октодерева, используемого для реконструкции поверхности, и, следовательно, подразумевает разрешение результирующей сетки треугольников. Более высокое значение глубины означает сетку с большим количеством деталей.

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_surface_reconstruction/fragment_rec.gif" /></p>

     Реконструкция поверхности Пуассона также создаст треугольники в областях с низкой плотностью точек и даже *экстраполируется* в некоторые области. Низкое значение плотности означает, что вершина поддерживается только небольшим количеством точек из входного облака точек.

     Также в коде мы визуализируем плотность в 3D с помощью псевдоцвета. Фиолетовый указывает на низкую плотность, а желтый - на высокую. В дальнейшем мы можем использовать значения плотности для удаления вершин и треугольников с низкой опорой. 

     Также в коде мы удаляем все вершины (и соединенные треугольники), которые имеют более низкое значение плотности, чем квантиль 0,01 всех значений плотности.

  4. **Normal estimation** В приведенных выше примерах мы предполагали, что у облака точек есть нормали, направленные наружу. Однако не все облака точек уже имеют соответствующие нормали. Open3D можно использовать для оценки нормалей облака точек с помощью valu_normals, которая локально соответствует плоскости на трехмерную точку для получения нормали. Однако оцененные нормали могут быть непостоянно ориентированы и распространяет нормальную ориентацию с использованием минимального остовного дерева.

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_surface_reconstruction/knot_norm.png" /></p>

- **COM6** - **Transformation** 

  1. **Translate** принимает один трехмерный вектор t в качестве входных данных и переводит все точки/вершины геометрии на этот вектор, vt = v + t, по выбору либо по x, либо по y, либо по z. 
  2. **Rotation** Он принимает в качестве первого аргумента матрицу вращения R. Вращения в 3D можно параметризовать несколькими способами:
     1. Преобразование из углов Эйлера (где xyz также может иметь форму yzx, zxy, xzy, zyx и yxz)
     2. Преобразование из представления угла оси
     3. Преобразование из кватернионов
  3. **Scale** Вершины и точки геометрических типов можно масштабировать vs = s⋅v.
  4. **General transformation** Open3D поддерживает общее преобразование, определяемое однородной матрицей преобразования 4 × 4 с использованием метода преобразования.

- **COM7** - **Mesh deformation** [ФОРМУЛА](http://www.open3d.org/docs/release/tutorial/geometry/mesh_deformation.html) Если мы хотим деформировать треугольную сетку в соответствии с небольшим количеством ограничений, мы можем использовать алгоритмы деформации сетки [SorkineAndAlexa2007]

  1. **Smoothed ARAP**

- **COM8** - **Intrinsic shape signatures (ISS)** [ФОРМУЛА](http://www.open3d.org/docs/release/tutorial/geometry/iss_keypoint_detector.html) Определить ключевые точки ISS трехмерной формы.

  1. **ISS Keypoints** (Каким то образом код вытаскивает ключевые точки, но совсем не понятно, нужно отдельно читать этих авторов [[27](https://github.com/aktumar/3D_reconstruction/blob/main/additional_info/references.md#14)], [[28](https://github.com/aktumar/3D_reconstruction/blob/main/additional_info/references.md#14)])
