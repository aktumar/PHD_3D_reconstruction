```
Open3D: A Modern Library for 3D Data Processing

Problems:
1. bunny.ply и прочие файлы не читаются. Так как в них отсутсвуют треугольники / Попробуй найти различие между bunny и knot, последнее работает прекрасно
2. При реализации кластеризации есть небольшой ассинхрон, в моем случае он работает иначе
3. fragment.pcd - Как можно резать облака точек, чтобы выводил конкретные данные, как в этом файле
4. Проблема mesh в том, что она не умеет вытаскивать цвета из файла
5. Средний фильтр и лаплассиан, особого различия не имеет, нужно как нибудь их сравнить 
6. А вот Таубиновый фильтр работатет совсем по другому, он не сжирает толщину
7. Выборка диска Пуассона, в чем прикол? Если в самом коде особого различия нет
8. При работе с RGBD, когда загружаю свои фотографии, то работает намного хуже, осталось понять, как вытащить глуюину из фотки
9. kNN который уканаз на сайте, и который вышел у меня очень отличаются. В моем случае все зеленым красится
```

- **COM1** - **Point cloud**

  1. **Visualize point cloud**. Сначала считываются данные облаков точек и визуализируются через библиотеку Open3D. Выглядит как плотная поверхность, но состоит из облаков точек, отображаемое в виде серфинга/точек(surfels).

  <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_pointclouds/fragment_g.gif" /></p>

  2. **Voxel downsampling**. **Воксельная субдискретизация** использует обычную *сетку вокселей* для создания однородно субдискретизированного облака точек из входного облака точек. Он часто используется в качестве этапа предварительной обработки для многих задач обработки - облака точек. **Алгоритм** работает в два этапа:

     1. Точки разбиты на воксели.
     2. Каждый занятый воксель генерирует ровно одну точку путем усреднения всех точек внутри.

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_pointclouds/fragment_v.png" /></p>

  3. **Vertex normal estimation**. Еще одна базовая операция для облака точек - это **оценка нормалей точек**. Функция находит соседние точки и вычисляет главную ось соседних точек с помощью ковариационного анализа. ***Алгоритм ковариационного анализа*** выдает два противоположных направления в качестве нормальных кандидатов. Не зная общей структуры геометрии, оба могут быть правильными. 

     Это известно как *проблема нормальной ориентации*. Open3D пытается сориентировать нормаль, чтобы выровнять ее с исходной нормалью, если она существует. В противном случае Open3D делает случайное предположение. 

  <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_pointclouds/fragment_n.gif" /></p>

  4. **Access estimated vertex normal**. (Показывают как вытащить векор нормали всех точек (XYZ).)

  5. **Crop point cloud**. (Через json есть возможность вытащить отдельные объекты. Но как это работает)

  <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_pointclouds/fragment_ch.png" /></p>

  6. **Paint point cloud**. (Uniform color.)

  7. **Point cloud distance**. Метод `compute_point_cloud_distance` для вычисления расстояния от исходного облака точек до целевого облака точек. То есть, он вычисляет для каждой точки в исходном облаке точек расстояние до ближайшей точки в целевом облаке точек. Обратите внимание, что этот метод также можно использовать для вычисления Chamfer distance между двумя облаками точек. (В данном случае мы показываем сцену, но удаляем стул)

  8. **Bounding volumes**. (Создает границы объекта в виде прямоугольника выровненный по абсциссе/ординате)

  9. **:question: Convex hull**. **Выпуклая оболочка облака точек** - это наименьшее выпуклое множество, содержащее все точки. Реализация основана на Qhull. В примере кода сначала выбирается облако точек из сетки и вычисляется выпуклая оболочка, которая возвращается как треугольная сетка. Затем визуализируется выпуклая оболочка как красный набор линий. - (Реализация не получилась, есть проблемы с данными. Выводит ошибку - bunny..tar.gz input mesh has no triangles, пока что заменила другим .ply)

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_pointclouds/knot_pc.gif" /></p>

  10. **DBSCAN clustering**. Учитывая облако точек из, например, датчик глубины (depth sensor), мы хотим сгруппировать локальные кластеры облака точек вместе. Для этого мы можем использовать **алгоритмы кластеризации**. Open3D реализует DBSCAN [Ester1996], который представляет собой алгоритм кластеризации на основе плотности. Этот алгоритм предварительно вычисляет всех соседей в эпсилон-радиусе для всех точек. Это может потребовать много памяти, если выбранный эпсилон слишком большой. (При реализации вывел 10 кластеров, но по виду вроде как 5. Вот бы выводить их по одному)

      <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_pointclouds/fragment_cl.png" /></p>

  11. **Plane segmentation**. Open3D поддерживает сегментирование геометрических примитивов из облаков точек с помощью **RANSAC**. (При реализации данного кода, он возвращает уравнение плоскости: -0.00x + 1.00y + 0.02z + -2.43 = 0. Интересно, что при загрузке fragment.ply он нашел лишь пол. А при fragment.pcd вывел заднюю стенку. Так же найденная плоскость прокрашивается в красный цвет)

  12. **:question: Hidden point removal**. Представьте, что вы хотите визуализировать облако точек из заданной точки обзора, но точки из фона просачиваются на передний план, потому что они не перекрываются другими точками. Для этого мы можем применить алгоритм удаления скрытых точек. В Open3D реализован метод [Katz2007], который аппроксимирует видимость облака точек из заданного вида без реконструкции поверхности или нормальной оценки. (Тему я поняла, но опять у меня проблема с входными данными. Нужно понять как работает open3d_tutorial. Пока что заменила другим .ply)

      <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_pointclouds/knot_hp.gif" /></p>

- **COM2** - **Mesh**. Open3D имеет структуру данных для трехмерных треугольных сеток, называемую `TriangleMesh`. Она считает треугольную сетку из файла слоя и печатает ее вершины и треугольники. (Класс TriangleMesh имеет несколько полей данных, таких как вершины и треугольники)

  1. **Visualize a 3D mesh**. Можно взаимодействовать с сеткой, но она окрашена в однородный серый цвет. Причина в том, что текущая сетка не имеет нормалей для вершин или граней. Таким образом, вместо более сложной штриховки Фонга используется равномерное цветовое затенение.

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_mesh/knot_g.gif" /></p>

  2. **Surface normal estimation**. (Высчитываются нормали, затем происходит рендер этих нормалей. Но по виду особого различия не вижу) 

  3. **Crop mesh**. (Тут удалили половину поверхности, с таким же успехом можно и на 5 поделить, и на 10. Но главное просто остальное не отображается, как в OpenGL)

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_mesh/knot_lot.gif" /></p>

  4. **Paint mesh**. (Меш обычно бесцветный, но ему можно дать UNIFORM цвет, RGB как всегда в промежутке [0,1])

  5. **Mesh properties**. Треугольная сетка имеет несколько свойств, которые можно протестировать с помощью Open3D.
  
     1. Одним из важных свойств является ***свойство многообразия***, с помощью которого мы можем проверить треугольную сетку, является ли это краевым многообразием. Сетка треугольников является краевым многообразием, если каждое ребро ограничивает один или два треугольника. Кроме того, треугольная сетка является вершинным многообразием, если звезда вершины является реберно-многообразной и реберной связью, например, две или более граней, соединенных только вершиной, а не ребром. (A triangle mesh is edge manifold, if each edge is bounding either one or two triangles. Further, a triangle mesh is vertex manifold if the star of the vertex is edge-manifold and edge-connected, e.g., two or more faces connected only by a vertex and not by an edge.)
     2. Еще одно свойство - ***тест самопересечения***.
     3. Можно протестировать треугольную сетку, если она ***ориентируема***, то есть треугольники могут быть ориентированы таким образом, что все нормали направлены наружу.
  
  6. **Mesh filtering**. Open3D содержит методs фильтрации сеток. Реализованы фильтры для сглаживания зашумленных треугольных сеток.
  
     1. **Average filter**. ([ФОРМУЛА](http://www.open3d.org/docs/release/tutorial/geometry/mesh.html#Average-filter)) Самый простой фильтр - это средний фильтр. Данная вершина vi задается средним значением соседних вершин N. (В коде сначала сделали искусственный шум, с размером 5/10/15, затем делают сглаживание в 1/5/10 итерации. Вот только, чем больше итерации, тем больше он жрет от поверхности)
  
     2. **Laplacian**. ([ФОРМУЛА](http://www.open3d.org/docs/release/tutorial/geometry/mesh.html#Laplacian)) (Визуально, особого различия не увидела, нужно понять в чем различие)
  
     3. **Taubin filter**. Проблема со средним и лапласовским фильтрами заключается в том, что они приводят к сжатию треугольной сетки. [Taubin1995] показал, что применение двух лапласовских фильтров с разными параметрами λ может предотвратить усадку сетки. (Короче, при лапласе и среднем фильтре, он жрет толщину. А тут толщину он не жрет даже при 50 итерации, но при этом есть небольшие пересечения)
  
  7. **Sampling**. Есть функции для выборки облаков точек из треугольной сетки. ***Самый простой метод*** - равномерно выбрать точки с 3D-поверхности на основе площади треугольника. Один из параметров определяет, сколько точек выбирается с поверхности треугольника. 
  
     Равномерная выборка может давать кластеры точек на поверхности, в то время как ***метод, называемый выборкой диска Пуассона***, может равномерно распределять точки на поверхности. Он начинается с облака точек выборки и удаляет точки, чтобы удовлетворить критерию выборки. Метод поддерживает два варианта создания начального облака точек:
  
     1. По умолчанию метод сначала равномерно отбирает облако точек из сетки и использует это для исключения.
     2. Можно предоставить облако точек и передать его методу, чтобы использовать для исключения.
  
     (В коде можно указать, сколько точек вытаскивать из меша. Если 5000 то много точек. Но прикол выборки диска Пуассона я вообще не поняла)
  
  8. **Mesh subdivision**. При разбиении сетки мы делим каждый треугольник на несколько меньших треугольников. В простейшем случае мы вычисляем среднюю точку каждой стороны треугольника и делим треугольник на четыре меньших треугольника. 3D-поверхность и площадь остаются прежними, но количество вершин и треугольников увеличивается.
  
     Open3D реализует дополнительный метод подразделения, основанный на [Loop1987]. Метод основан на квадратичном сплайне квадрата, который генерирует непрерывные предельные поверхности C2 везде, кроме необычных вершин, где они являются C1 непрерывными. Это приводит к более гладким углам.ф
  
  9. **Mesh simplification**. Иногда мы хотим представить сетку высокого разрешения с меньшим количеством треугольников и вершин, но сетка с низким разрешением все равно должна быть близка к сетке с высоким разрешением.
  
     1. **Vertex clustering**. Метод кластеризации вершин объединяет все вершины, которые попадают в воксель заданного размера, в одну вершину. (Чем ниже число, тем меньше полигонов)
     2. **Mesh decimation**. Другой категорией методов упрощения сетки является прореживание сетки, которое работает поэтапно. Мы выбираем один треугольник, который минимизирует метрику ошибки и удаляет ее. Это повторяется до тех пор, пока не будет получено необходимое количество треугольников. (Чем ниже число, тем меньше полигонов, и они длинные почему то)
  
  10. **Connected components**. Это полезно, например, при интеграции RGBD, которая не всегда представляет собой единую треугольную сетку, а представляет собой несколько сеток. Некоторые мелкие детали возникают из-за шума, и мы, скорее всего, захотим их удалить.


- **COM3** - **RGBD images.** Open3D имеет ***структуру данных*** для изображений. Он поддерживает различные функции, такие как `read_image`, `write_image`, `filter_image` и `draw_geometries`. Изображение Open3D можно напрямую преобразовать в / из массива numpy.

  Open3D RGBDImage состоит из двух изображений: `RGBDImage.depth` и `RGBDImage.color`. We require the two images to be registered into the *same camera frame* and have the *same resolution*.

  1. **Redwood dataset.** [Choi2015] Формат Redwood сохраняет глубину в 16-битном одноканальном изображении. Целочисленное значение представляет собой измерение глубины в миллиметрах. Это формат по умолчанию для Open3D для анализа изображений глубины.

     Функция преобразования по умолчанию `create_rgbd_image_from_color_and_depth` создает RGBDImage из пары изображения цвета и глубины. 

     1. *Цветное изображение* преобразуется в изображение в градациях серого, сохраняемое в виде числа с плавающей запятой в диапазоне [0, 1]. 
     2. *Изображение глубины* сохраняется в формате float, представляя значение глубины в метрах.

     Преобразованные изображения могут быть отображены как массивы numpy. Изображение RGBD можно преобразовать в облако точек с учетом набора параметров камеры. 

     Здесь мы используем `PinholeCameraIntrinsicParameters.PrimeSenseDefault` в качестве параметра камеры по умолчанию. Он имеет: 

     1. разрешение изображения 640x480, 
     2. фокусное расстояние (fx, fy) = (525,0, 525,0)
     3. оптический центр (cx, cy) = (319,5, 239,5). 

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_rgbd_images/fragment_rgbd.gif" /></p>

     (При использовании изображений из других источников, есть погрешности, хотя сами фотографии выглядят не идеально)

     <p align="center"><img width="40%" src="https://github.com/aktumar/3D_Machine_Learning_Recognition_Py/blob/master/tutorials/input-output/t_rgbd_images/site_images_rgbd.gif" /></p>

  2. **SUN dataset.**

  3. **NYU dataset.** [Silberman2012] Отличие от Redwood и  SUN: изображения NYU не в стандартных форматах jpg или png. Таким образом, мы используем `mpimg.imread` для чтения цветного изображения как массива numpy. 

  4. **TUM dataset.** [Strum2012]

- **COM4** - **KDTree.** Open3D использует FLANN для построения KDTrees для быстрого поиска ближайших соседей.

  1. **Build KDTree from point cloud.** (Cчитывает облако точек и строит KDTree) Это этап предварительной обработки для следующих запросов ближайшего соседа.
  2. **Find neighboring points.** Мы выбираем 1500-ю точку в качестве точки привязки и окрашиваем ее в красный цвет. 
     1. **Using search_knn_vector_3d.**
     2. **Using search_radius_vector_3d.**

  Помимо поиска **KNN** `search_knn_vector_3d` и поиска **RNN** `search_radius_vector_3d`, Open3D предоставляет функцию гибридного поиска `search_hybrid_vector_3d`. Он возвращает не более k ближайших соседей, расстояние до точки привязки которых меньше заданного радиуса. Эта функция объединяет критерии поиска KNN и поиска RNN. В некоторых литературных источниках он известен как поиск RKNN. Он дает преимущества в производительности во многих практических случаях и активно используется в ряде функций Open3D.

